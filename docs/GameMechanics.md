### Game Mechanics

The user is presented with a square matrix, which must be "uncovered". Each matrix is made of pairs of different visual shapes and colors. For the sake of the demo, we only used colors: red, green, blue and orange, but in future version we will use dice, hexagrams, basic geometric shapes (circle, square, triangle, hexagon), etc. 

User taps two distinct, uncovered yet squares. A request is sent to the blockchain, which alters the state of the smart contract. The app has set up a listener for this specific state change (name of event: `GameTurn`); When the app received the emitted event, two things can happen:

- if the squares are identical (same shape and color), they remain uncovered
- if the squares are different (different shape and color), they are briefly presented to the user, then they are flipped back to "uncovered" state. 

In both cases, the state is persisted on chain.

As the game advances, when there are only `sqrt(boardSize)` tiles uncovered (e.g.: boardSize is 16, so we have a 4x4 matrix, when we have only 4 tiles uncovered) the logic changes. Each request will return a matching pair of tiles, so the last two requests are always solving the game. The caveat here is that, if any of these squares has been uncovered before, its color might change when the tile is "solved".

After the entire matrix is solved, it is turned into an on-chain NFT (Base64 encoding it into the abi, using SVG).

## Levels

The game starts with a 4x4 matrix. After uncovering 8 such matrixes, the game advances to the next level, which uses 8x8 matrixes (64 tiles). 

The tiles used in the second level are the ones uncovered in the first level. So in the second level, the matching pairs are not red, blue, green, orange, but one of the 8 NFTs already generated. The visual combination will still have the initial basic "pixels", but on a different, larger surface, and with the constraints of the already generated tiles.

After 16 matrixes uncovered in the second level, the game advances to the next (and last level), which will be based on 16x16 matrixes (256 tiles). Each tile here will be one of the 16 matrixes uncovered in the previous level.

## Goal

The goal of the game is to generate NFT primitives, or basic shapes that can be then assembled in on-chain art. Each NFT can be sold in a marketplace, so people looking for a specific combination needed for their digital painting can buy it, if it was already generated by someone else. Or they can choose to play the game again and again, until randomness will generate their specific tile.

A buying event will break the level logic. For instance, if someone buys one of your 8 level 1 matrixes, you will be left with only 7, so yo need to generate a new one before being able to play at level 2 or 3.

## Randomness

Although the game proposition is that we have to uncover a matrix, the matrix starts empty. There is no pre-generated matrix that the user can inspect by looking up the smart contract variables. Instead, we generate random numbers on each request (in the matrix interval: so, if we have a 4x4 matrix, we only use 4 shapes, so we generate random numbers in the 1 - 4 interval). 

This approach reduces the possibility of cheating and "validates" each generated NFT as PoA (Proof of Attention).